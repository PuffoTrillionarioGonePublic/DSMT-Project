package com.erldb

import java.sql.*

abstract class AbstractStatement : Statement {
    fun unsupported(): SQLException {
        return SQLFeatureNotSupportedException("not implemented by SQLite JDBC driver")
    }

    // Statement ////////////////////////////////////////////////////
    override fun execute(sql: String?, colinds: IntArray?): Boolean {
        throw unsupported()
    }

    override fun execute(sql: String?, colnames: Array<String?>?): Boolean {
        throw unsupported()
    }

    override fun executeUpdate(sql: String?, colinds: IntArray?): Int {
        throw unsupported()
    }

    override fun executeUpdate(sql: String?, cols: Array<String?>?): Int {
        throw unsupported()
    }

    override fun executeLargeUpdate(sql: String?, colinds: IntArray?): Long {
        throw unsupported()
    }

    override fun executeLargeUpdate(sql: String?, cols: Array<String?>?): Long {
        throw unsupported()
    }


    override fun clearWarnings() {
    }


    override fun getWarnings(): SQLWarning? = null


    override fun setPoolable(poolable: Boolean) {
        // no-op
    }

    override fun isPoolable(): Boolean = false

    override fun setEscapeProcessing(enable: Boolean) {
        // no-op
    }

    override fun setCursorName(name: String?) {}
    override fun execute(sql: String, autoGeneratedKeys: Int): Boolean = execute(sql)
    override fun executeUpdate(sql: String, autoGeneratedKeys: Int): Int = executeUpdate(sql)
    override fun executeLargeUpdate(sql: String, autoGeneratedKeys: Int): Long = executeLargeUpdate(sql)

    override fun setFetchDirection(direction: Int) {
        if (direction != ResultSet.FETCH_FORWARD && direction != ResultSet.FETCH_REVERSE && direction != ResultSet.FETCH_UNKNOWN) throw SQLException(
            "Unknown fetch direction $direction. Must be one of FETCH_FORWARD, FETCH_REVERSE, or FETCH_UNKNOWN in java.sql.ResultSet"
        )
    }

    override fun getFetchDirection(): Int = ResultSet.FETCH_FORWARD
    override fun getResultSetConcurrency(): Int = ResultSet.CONCUR_READ_ONLY
    override fun getResultSetType(): Int = ResultSet.TYPE_FORWARD_ONLY

    override fun getResultSetHoldability(): Int = ResultSet.CLOSE_CURSORS_AT_COMMIT
    override fun getMaxFieldSize(): Int = 0
    override fun setMaxFieldSize(max: Int) {
        if (max < 0) throw SQLException("max field size $max cannot be negative")
    }

    override fun getMaxRows(): Int = largeMaxRows.toInt()

    override fun setMaxRows(max: Int) {
        largeMaxRows = max.toLong()
    }

    override fun executeUpdate(sql: String): Int = executeLargeUpdate(sql).toInt()

    override fun getUpdateCount(): Int = largeUpdateCount.toInt()


    override fun <T> unwrap(iface: Class<T>): T = iface.cast(this)


    override fun isWrapperFor(iface: Class<*>): Boolean = iface.isInstance(this)

    override fun getMoreResults(): Boolean = getMoreResults(Statement.CLOSE_CURRENT_RESULT)

    override fun setFetchSize(r: Int) {
        throw SQLFeatureNotSupportedException("setFetchSize")
    }

    override fun getFetchSize(): Int {
        throw SQLFeatureNotSupportedException("getFetchSize")
    }

}